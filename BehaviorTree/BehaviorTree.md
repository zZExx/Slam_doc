# **行为树（Behavior Tree, BT）**

# 1. 是什么

## 1.1 BT 的定义

行为树（Behavior Tree, BT）是一种用树状结构组织智能体行为逻辑的决策模型。在游戏领域，行为树已经比较流行了。主要用于维护游戏角色的各种动作和状态。这里可以将character换成叉车，用于维护叉车的action及state。
它具有以下核心特点：

* **层次化结构**：使用树节点表达行为逻辑。
* **Tick 驱动执行模型**：根节点周期性被 tick，状态沿树传播，节点返回三种状态：

  * `SUCCESS`
  * `FAILURE`
  * `RUNNING`
* **逻辑与行为解耦**：高层（控制策略）与底层（动作实现）分离，提高可复用性。
* **组件化与可编排性**：通过组合节点可以构建复杂任务流程，易调试、易拓展。
  
---

## 1.2 BT 与 FSM（有限状态机）对比

| 维度          | BT（行为树）                      | FSM（有限状态机）                      |
| ----------- | ---------------------------- | ------------------------------- |
| **结构复杂度**   | 层级结构天然支持组合、复用，复杂度随树深度线性增长    | 状态和状态间迁移呈指数级膨胀（State Explosion） |
| **逻辑修改成本**  | 可独立修改子树，影响范围可控               | 改一个状态可能影响多个转移，维护成本高             |
| **并行与中断能力** | 支持并行节点、优先级节点、守护节点（Decorator） | 中断通常需显式建状态，结构复杂                 |
| **可读性与可视化** | 可直接图形化表达                     | 状态机复杂后难理解                       |
| **重复行为复用**  | 子树可复用                        | 需重复建状态或使用嵌套子状态（复杂）              |
| **适用场景**    | 有层级结构、流程多变、需容错的场景（机器人）       | 逻辑简单、状态少、确定性强的场景（协议、硬件）         |

### 总结

* **FSM 适合“确定流程、离散事件少”的系统**。
* **BT 适合“复杂流程、混合行为、需要容错”的机器人系统**。
  无人叉车属于后者，因此 BT 更合适。

---

# 2. 干什么

## 2.1 BT 在无人叉车系统中能干什么

无人叉车（AGF / laser AGV）典型特征：

* 多任务调度
* 多阶段作业（导航 / 对位 / 穿叉 / 升降 / 放置）
* 同时需兼容安全检测、导航、避障、重规划、故障处理

**BT 在无人叉车系统中的典型功能包括：**

###  任务级决策

* 接收任务（取货、卸货、其他调度指令）
* 根据黑板（Blackboard）中的任务参数自动分解流程
* 不同任务类型通过复用子树完成（取货、卸货等）

###  动作与子任务组织

* 导航 -> 停靠 -> 对位 -> 升降 -> 抓取/放置
* 使用 Sequence、Selector 做条件判断与子流程切换
* 支持失败回退（Fallback）提高鲁棒性

###  安全逻辑

* 随时检测急停信号
* 障碍物检测、避障失败重规划
* 货物状态检查
* 信号连接情况

###  异常恢复

* 导航失败 -> 重规划
* 抓取失败 -> 再次对位/重新插叉
* 放置失败 -> 重试或报警
* 故障 -> 集成 fallback 节点进入安全模式
* 货物状态异常 -> ????

---

## 2.2 无人叉车典型作业场景 & BT 能做什么

###  场景 1：取货 -> 运送 -> 卸货

流程：

1. 导航到托盘 A
2. 自动对位
3. 穿叉 + 升起
4. 导航到目标点
5. 放下托盘并退出

对应 BT 功能：

* 用一个 Sequence 表达完整作业流程
* 在导航失败时，Selector 自动执行 “ReplanRoute”
* 在取货失败时进入 “重新对位” 子树
* parallel repeat执行安全状态监控

---

###  场景 2：充电流程 / 低电回库

流程：

* 检查电量 -> 低电 -> 停工 -> 前往充电站 -> 对位 -> 进入充电模式
  这是典型 “Selector + Sequence” 的 BT 结构。

---

# **3. 怎么用（BT 的语法介绍 & Nav2 节点说明）**

行为树的“语法”并不是某种编程语言，而是一套**结构化的逻辑规则**。就像搭积木一样，通过固定类型的节点进行组合，构成机器人完整的决策过程。
下面以概念、节点类型、组合规则为重点描述 BT 的语法体系。

---

# **3.1 行为树语法总体概念**

行为树的基础语法由三部分组成：

1. **树状结构**（父节点管理子节点）
2. **节点执行规则**（不同类型节点有不同逻辑）
3. **节点返回状态**（Success / Failure / Running）

其核心思想是：

> **行为树通过控制节点（流程）、装饰节点（修饰）、叶子节点（动作）三类“语法单元”，组合成复杂行为逻辑。**

你可以将 BT 的语法理解为：
**用一组固定“语义节点”构造流程图，但它是可执行的、带状态的、可恢复的。**

---

# **3.2 行为树的三大语法单元**

## **（1）控制节点（Control）**

控制节点决定子节点的执行顺序，是 BT 的“语法结构骨架”。

控制节点的行为都遵循同一个规则结构：

1. 接收 tick
2. 按自身的策略执行多个子节点
3. 根据子节点的结果返回 Success/Failure/Running

### 控制节点的语法角色类似：

* `Sequence` -> **顺序语句**（先做A再做B）
* `Fallback/Selector` -> **条件语句**（如果A不行就试B）
* `Parallel` -> **并行语句**（A 和 B 同时执行）

### 各控制节点对应的语法语义：

| 控制节点                                    | 语义解释            | 常用语法功能      |
| --------------------------------------- | --------------- | ----------- |
| **Sequence（顺序节点）**                      | “所有子节点必须按顺序成功”  | 实现完整作业流程    |
| **Selector/Fallback（选择节点）**             | “尝试多个方案，成功一个即可” | 异常恢复、容错逻辑   |
| **Parallel（并行节点）**                      | “多个行为同时执行”      | 安全监控、导航同时进行 |
| **ReactiveSelector / ReactiveSequence** | “每一 tick 都从头检查” | 强实时性流程，如避障  |

---

## **（2）装饰节点（Decorator）**

装饰器是**单输入的修饰符**，语法意义类似于：

* if 过滤
* 超时限制
* 重试包装
* 执行结果改写（如 Inverter）

装饰节点不定义行为，只是**修改子节点的行为逻辑或返回值**。

常见语法功能解释如下：

| 装饰器                             | 语义解释        | 常用于           |
| ------------------------------- | ----------- | ------------- |
| **Inverter**                    | 成功->失败，失败->成功 | 反向条件判断，如“无障碍” |
| **Retry Until N**               | 失败时自动重试     | 抓取失败重复对位      |
| **Timeout**                     | 限时执行        | 导航超时          |
| **Condition / Guard**           | 先判断条件再执行动作  | 电量检查、安全检查     |
| **ForceSuccess / ForceFailure** | 强制覆盖结果      | 容错或忽略小问题      |

装饰节点体现了 BT “模块可塑性强”的语法风格：

> **无需修改动作，只用装饰器就能改变逻辑路径。**

---

## **（3）叶子节点（Leaf）**

叶子节点是真正执行行为的“基本语法单元”。
分为两类：

### **Condition（条件节点）**

* 不执行动作，只判断某个状态
* 通常立即返回 Success 或 Failure

语法功能：

> **控制流程走向，相当于 if 条件。**

例如：电量、障碍物、货物状态、传感器状态、任务参数是否有效等。

---

### **Action（动作节点）**

* 执行具体操作（导航、升叉、插叉、放货等）
* 执行过程中返回 `RUNNING`
* 完成后返回 `SUCCESS` 或 `FAILURE`

语法功能：

> **Action 是行为树中最基本的可执行语句。**

---

# **3.3 行为树运行语法—Tick 机制**

行为树不是一次执行完，而是不断被“Tick”：

1. **根节点每周期被 Tick（例如 10Hz）**
2. Tick 沿树向下传递
3. 每个节点按规则执行并返回状态
4. 返回状态自下往上回传，决定是否继续执行下个节点

Tick 机制的语法性特点：

* **Sequence** 遇到 running 会暂存状态
* **Selector** 遇到 success 会终止其他分支
* **Reactive 节点** 会在每个 tick 从头检查条件
* **Parallel** 每 tick 处理多个节点

BT 的 Tick 机制决定了它可以：

* 随时中断动作（例如安全制动）
* 随时替换子行为（例如避障/重规划）
* 在 Running 中持续执行（如导航过程）

这是 FSM 做不到的。

---

# **3.4 Nav2 的行为树语法扩展（概念级）**

Nav2 采用 BehaviorTree.CPP 并扩展了一些语法概念。

## **（1）基于数据黑板（Blackboard）的参数传递语法**

在 Nav2 中：

* 全局目标点、当前路径、机器人状态
* 都以“键值对”的方式存在黑板中
* 节点间通过黑板共享信息（类似上下文变量）

语法特点：

> **Action 不需要知道来源，只从黑板读取。**
> **Sequence 中的节点通过黑板自动共享状态。**

---

## **（2）Nav2 的强类型节点体系**

Nav2 的 BT 节点分为：

* **Condition 节点（检查状态）**
* **Action 节点（执行导航或局部动作）**
* **Control 节点（由 BT 框架提供）**

它们遵循统一的 BT 语法规则，但 Nav2 把许多机器人行为封装成标准节点，例如：

* “生成路径”
* “执行路径跟随”
* “清除 costmap”
* “导航恢复行为”

这些本质上都属于叶子节点，但具有机器人特化语义。

---

## **（3）Nav2 的“恢复语法”模式**

Nav2 会统一使用 Fallback + RecoveryNode 构造“恢复树”：

* 正常动作失败 -> 进入恢复动作
* 恢复动作成功 -> 回到正常流程
* 多次恢复失败 -> 返回 Failure

这是一种 Nav2 固定的行为树语法模式。

---

# **3.5 行为树语法总结（关键语法点）**

| 语法点               | 说明                             |
| ----------------- | ------------------------------ |
| **树结构即语法结构**      | 通过父子节点描述流程                     |
| **Tick 驱动运行语法**   | 行为树通过周期性 Tick 执行节点             |
| **三类节点构成语法基础**    | 控制节点、装饰节点、叶子节点                 |
| **节点返回值是语法流程的核心** | Success/Failure/Running 决定流程走向 |
| **使用黑板传递参数**      | 是 Nav2 的标准语法机制                 |
| **通过组合构建复杂流程**    | Sequence + Selector 是最基本语法结构   |
| **通过装饰器修改行为逻辑**   | 超时、重试、条件判断都靠 Decorator         |
| **容错语法（Nav2 特色）** | RecoveryNode + Fallback 构成恢复机制 |

---

